<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Introduction</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="up" href="multi_spring-cloud-pipelines.html" title="Spring Cloud Pipelines"><link rel="prev" href="multi__the_opinionated_pipeline.html" title="1.&nbsp;The opinionated pipeline"><link rel="next" href="multi_concourse.html" title="3.&nbsp;Concourse Pipeline"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Introduction</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="multi__the_opinionated_pipeline.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="multi_concourse.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="_introduction" href="#_introduction"></a>2.&nbsp;Introduction</h1></div></div></div><p>In the following section we will describe in more depth the rationale
behind the presented opinionated pipeline. We will go through each deployment
step and describe it in details.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_project_setup" href="#_project_setup"></a>2.1&nbsp;Project setup</h2></div></div></div><pre class="programlisting">.
&#9500;&#9472;&#9472; common
&#9500;&#9472;&#9472; concourse
&#9500;&#9472;&#9472; docs
&#9492;&#9472;&#9472; jenkins</pre><p>In the <code class="literal">common</code> folder you can find all the Bash scripts containing the pipeline logic. These
scripts are reused by both Concourse and Jenkins pipelines.</p><p>In the <code class="literal">concourse</code> folder you can find all the necessary scripts and setup to run Concourse demo.</p><p>In the <code class="literal">docs</code> section you have the whole documentation of the project.</p><p>In the <code class="literal">jenkins</code> folder you can find all the necessary scripts and setup to run Jenkins demo.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_how_to_use_it" href="#_how_to_use_it"></a>2.2&nbsp;How to use it?</h2></div></div></div><p>This repository can be treated as a template for your pipeline. We provide some opinionated
implementation that you can alter to suit your needs. The best approach to use it
to build your production projects would be to download the Spring Cloud Pipelines repository as ZIP, then
init a Git project there and modify it as you wish.</p><pre class="programlisting">$ curl -LOk https://github.com/spring-cloud/spring-cloud-pipelines/archive/v1.<span class="hl-number">0.0</span>.M4.zip
$ unzip v1.<span class="hl-number">0.0</span>.M4.zip
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">cd</span> spring-cloud-pipelines-v1.<span class="hl-number">0.0</span>.M4
$ git init
$ <span xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># modify the pipelines to suit your needs</span>
$ git add .
$ git commit -m <span xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Initial commit"</span>
$ git remote add origin ${YOUR_REPOSITORY_URL}
$ git push origin master</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Why aren&#8217;t you simply cloning the repo? This is meant to be a seed
for building new, versioned pipelines for you. You don&#8217;t want to have all of our
history dragged along with you, don&#8217;t you?</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_the_flow" href="#_the_flow"></a>2.3&nbsp;The flow</h2></div></div></div><p>Let&#8217;s take a look at the flow of the opinionated pipeline</p><div class="figure"><a name="d0e336" href="#d0e336"></a><p class="title"><b>Figure&nbsp;2.1.&nbsp;Flow in Concourse</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/flow_concourse.png" alt="flow concourse"></div></div></div><br class="figure-break"><div class="figure"><a name="d0e345" href="#d0e345"></a><p class="title"><b>Figure&nbsp;2.2.&nbsp;Flow in Jenkins</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/flow.png" alt="flow"></div></div></div><br class="figure-break"><p>We&#8217;ll first describe the overall concept behind the flow and then
we&#8217;ll split it into pieces and describe every piece independently.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_environments" href="#_environments"></a>2.4&nbsp;Environments</h2></div></div></div><p>So we&#8217;re on the same page let&#8217;s define some common vocabulary. We discern 4 typical
environments in terms of running the pipeline.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">build</li><li class="listitem">test</li><li class="listitem">stage</li><li class="listitem">prod</li></ul></div><p><span class="strong"><strong>Build</strong></span> environment is a machine where the building of the application takes place.
It&#8217;s a CI / CD tool worker.</p><p><span class="strong"><strong>Test</strong></span> is an environment where you can deploy an application to test it. It doesn&#8217;t
resemble production, we can&#8217;t be sure of it&#8217;s state (which application is deployed there
and in which version). It can be used by multiple teams at the same time.</p><p><span class="strong"><strong>Stage</strong></span> is an environment that does resemble production. Most likely applications
 are deployed there in versions that correspond to those deployed to production.
 Typically databases there are filled up with (obfuscated) production data. Most
 often this environment is a single, shared one between many teams. In other
 words in order to run some performance, user acceptance tests you have to block
 and wait until the environment is free.</p><p><span class="strong"><strong>Prod</strong></span> is a production environment where we want our tested applications to be deployed
for our customers.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="_tests" href="#_tests"></a>2.5&nbsp;Tests</h2></div></div></div><p><span class="strong"><strong>Unit tests</strong></span> - tests that are executed on the application during the build phase.
No integrations with databases / HTTP server stubs etc. take place. Generally speaking your application should
 have plenty of these to have fast feedback if your features are working fine.</p><p><span class="strong"><strong>Integration tests</strong></span> - tests that are executed on the built application during the build phase.
Integrations with in memory databases / HTTP server stubs take place. According to the test
pyramid, in most cases you should have not too many of these kind of tests.</p><p><span class="strong"><strong>Smoke tests</strong></span> - tests that are executed on a deployed application. The concept of these tests
is to check the crucial parts of your application are working properly. If you have 100 features
in your application but you gain most money from e.g. 5 features then you could write smoke tests
 for those 5 features. As you can see we&#8217;re talking about smoke tests of an application, not of
 the whole system. In our understanding inside the opinionated pipeline, these tests are
 executed against an application that is surrounded with stubs.</p><p><span class="strong"><strong>End to end tests</strong></span> - tests that are executed on a system composing of multiple applications.
The idea of these tests is to check if the tested feature works when the whole system is set up.
Due to the fact that it takes a lot of time, effort, resources to maintain such an environment
and that often those tests are unreliable (due to many different moving pieces like network
database etc.) you should have a handful of those tests. Only for critical parts of your business.
Since only production is the key verifier of whether your feature works, some companies
don&#8217;t even want to do those and move directly to deployment to production. When your
system contains KPI monitoring and alerting you can quickly react when your deployed application
is not behaving properly.</p><p><span class="strong"><strong>Performance testing</strong></span> - tests executed on an application or set of applications
to check if your system can handle big load of input. In case of our opinionated pipeline
 these tests could be executed either on test (against stubbed environment) or
  stage (against the whole system)</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_testing_against_stubs" href="#_testing_against_stubs"></a>2.5.1&nbsp;Testing against stubs</h3></div></div></div><p>Before we go into details of the flow let&#8217;s take a look at the following example.</p><div class="figure"><a name="d0e418" href="#d0e418"></a><p class="title"><b>Figure&nbsp;2.3.&nbsp;Two monolithic applications deployed for end to end testing</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/monolith.png" alt="monolith"></div></div></div><br class="figure-break"><p>When having only a handful of applications, performing end to end testing is beneficial.
From the operations perspective it&#8217;s maintainable for a finite number of deployed instances.
From the developers perspective it&#8217;s nice to verify the whole flow in the system
for a feature.</p><p>In case of microservices the scale starts to be a problem:</p><div class="figure"><a name="d0e431" href="#d0e431"></a><p class="title"><b>Figure&nbsp;2.4.&nbsp;Many microservices deployed in different versions</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/many_microservices.png" alt="many microservices"></div></div></div><br class="figure-break"><p>The questions arise:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">Should I queue deployments of microservices on one testing environment or should I have an environment per microservice?</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">If I queue deployments people will have to wait for hours to have their tests ran - that can be a problem</li></ul></div></li><li class="listitem"><p class="simpara">To remove that issue I can have an environment per microservice</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">Who will pay the bills (imagine 100 microservices - each having each own environment).</li><li class="listitem">Who will support each of those environments?</li><li class="listitem">Should we spawn a new environment each time we execute a new pipeline and then wrap it up or should we have
them up and running for the whole day?</li></ul></div></li><li class="listitem"><p class="simpara">In which versions should I deploy the dependent microservices - development or production versions?</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">If I have development versions then I can test my application against a feature that is not yet on production.
That can lead to exceptions on production</li><li class="listitem">If I test against production versions then I&#8217;ll never be able to test against a feature under development
anytime before deployment to production.</li></ul></div></li></ul></div><p>One of the possibilities of tackling these problems is to&#8230;&#8203; not do end to end tests.</p><div class="figure"><a name="d0e475" href="#d0e475"></a><p class="title"><b>Figure&nbsp;2.5.&nbsp;Execute tests on a deployed microservice on stubbed dependencies</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stubbed_dependencies.png" alt="stubbed dependencies"></div></div></div><br class="figure-break"><p>If we stub out all the dependencies of our application then most of the problems presented above
disappear. There is no need to start and setup infrastructure required by the dependant
microservices. That way the testing setup looks like this:</p><div class="figure"><a name="d0e486" href="#d0e486"></a><p class="title"><b>Figure&nbsp;2.6.&nbsp;We&#8217;re testing microservices in isolation</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stubbed_dependencies.png" alt="stubbed dependencies"></div></div></div><br class="figure-break"><p>Such an approach to testing and deployment gives the following benefits
(thanks to the usage of <a class="link" href="http://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html" target="_top">Spring Cloud Contract</a>):</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">No need to deploy dependant services</li><li class="listitem">The stubs used for the tests ran on a deployed microservice are the same as those used during integration tests</li><li class="listitem">Those stubs have been tested against the application that produces them (check <a class="link" href="http://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html" target="_top">Spring Cloud Contract</a> for more information)</li><li class="listitem">We don&#8217;t have many slow tests running on a deployed application - thus the pipeline gets executed much faster</li><li class="listitem">We don&#8217;t have to queue deployments - we&#8217;re testing in isolation thus pipelines don&#8217;t interfere with each other</li><li class="listitem">We don&#8217;t have to spawn virtual machines each time for deployment purposes</li></ul></div><p>It brings however the following challenges:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">No end to end tests before production - you don&#8217;t have the full certainty that a feature is working</li><li class="listitem">First time the applications will talk in a real way will be on production</li></ul></div><p>Like every solution it has its benefits and drawbacks. The opinionated pipeline
 allows you to configure whether you want to follow this flow or not.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_general_view" href="#_general_view"></a>2.5.2&nbsp;General view</h3></div></div></div><p>The general view behind this deployment pipeline is to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">test the application in isolation</li><li class="listitem">test the backwards compatibility of the application in order to roll it back if necessary</li><li class="listitem">allow testing of the packaged app in a deployed environment</li><li class="listitem">allow user acceptance tests / performance tests in a deployed environment</li><li class="listitem">allow deployment to production</li></ul></div><p>Obviously the pipeline could have been split to more steps but it seems that all of the aforementioned
 actions comprise nicely in our opinionated proposal.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_opinionated_implementation" href="#_opinionated_implementation"></a>2.5.3&nbsp;Opinionated implementation</h3></div></div></div><p>For the demo purposes we&#8217;re providing Docker Compose setup with Artifactory and Concourse / Jenkins tools.
Regardless of the picked CD application for the pipeline to pass one needs a Cloud Foundry instance (for example
<a class="link" href="https://run.pivotal.io/" target="_top">Pivotal Web Services</a> or <a class="link" href="https://pivotal.io/pcf-dev" target="_top">PCF Dev</a>) and the
infrastructure applications deployed to the JAR hosting application (for the demo we&#8217;re providing Artifactory).
The infrastructure applications are <code class="literal">Eureka</code> for Service Discovery and <code class="literal">Stub Runner Boot</code> for running
Spring Cloud Contract stubs.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td align="left" valign="top"><p>In the demos we&#8217;re showing you how to first build the <code class="literal">github-webhook</code> project. That&#8217;s because
the <code class="literal">github-analytics</code> needs the stubs of <code class="literal">github-webhook</code> to pass the tests. Below you&#8217;ll find
references to <code class="literal">github-analytics</code> project since it contains more interesting pieces as far as testing
is concerned.</p></td></tr></table></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_build" href="#_build"></a>Build</h4></div></div></div><div class="figure"><a name="d0e591" href="#d0e591"></a><p class="title"><b>Figure&nbsp;2.7.&nbsp;Build and upload artifacts</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/build.png" alt="build"></div></div></div><br class="figure-break"><p>In this step we&#8217;re generating a version of the pipeline, next we&#8217;re
 running unit, integration and contract tests. Finally we&#8217;re publishing
2 artifacts to Artifactory / Nexus:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">a fat jar of the application</li><li class="listitem">a Spring Cloud Contract jar containing stubs of the application</li></ul></div><p>During this phase we&#8217;re executing a <code class="literal">Maven</code> build using Maven Wrapper or a <code class="literal">Gradle</code> build using Gradle Wrapper
, with unit and integration tests. We&#8217;re also <span class="strong"><strong>tagging</strong></span> the repository with <code class="literal">dev/${version}</code> format. That way in each
subsequent step of the pipeline we&#8217;re able to retrieve the tagged version. Also we know
exactly which version of the pipeline corresponds to which Git hash.</p><p>Once the artifact got built we&#8217;re running API compatibility check.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">we&#8217;re searching for the latest production deployment</li><li class="listitem">we&#8217;re retrieving the contracts that were used by that deployment</li><li class="listitem">from the contracts we&#8217;re generating API tests to see if the current implementation
is fulfilling the HTTP / messaging contracts that the current production deployment
has defined (we&#8217;re checking backward compatibility of the API)</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_test" href="#_test"></a>Test</h4></div></div></div><div class="figure"><a name="d0e638" href="#d0e638"></a><p class="title"><b>Figure&nbsp;2.8.&nbsp;Smoke test and rollback test on test environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/test.png" alt="test"></div></div></div><br class="figure-break"><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">starting a RabbitMQ service in Cloud Foundry</li><li class="listitem">deploying <code class="literal">Eureka</code> infrastructure application to Cloud Foundry</li><li class="listitem">downloading the fat jar from Nexus and we&#8217;re uploading it to Cloud Foundry. We want the application
to run in isolation (be surrounded by stubs). Currently due to port constraints in Cloud Foundry
we cannot run multiple stubbed HTTP services in the cloud so to fix this issue we&#8217;re running
the application with <code class="literal">smoke</code> Spring profile on which you can stub out all HTTP calls to return
a mocked response</li><li class="listitem">if the application is using a database then it gets upgraded at this point via Flyway, Liquibase
or any other tool once the application gets started</li><li class="listitem">from the project&#8217;s Maven or Gradle build we&#8217;re extracting <code class="literal">stubrunner.ids</code> property that contains
all the <code class="literal">groupId:artifactId:version:classifier</code> notation of dependant projects for which
the stubs should be downloaded.</li><li class="listitem">then we&#8217;re uploading <code class="literal">Stub Runner Boot</code> and pass the extracted <code class="literal">stubrunner.ids</code> to it. That way
we&#8217;ll have a running application in Cloud Foundry that will download all the necessary stubs
of our application</li><li class="listitem">from the checked out code we&#8217;re running the tests available under the <code class="literal">smoke</code> profile. In the
case of <a class="link" href="https://github.com/spring-cloud-samples/github-analytics/" target="_top">GitHub Analytics</a> application
we&#8217;re triggering a message from the <a class="link" href="https://github.com/spring-cloud-samples/github-webhook" target="_top">GitHub Webhook</a>
application&#8217;s stub, that is sent via RabbitMQ to GitHub Analytics. Then we&#8217;re checking if
message count has increased. You can check those tests <a class="link" href="https://github.com/spring-cloud-samples/github-analytics/blob/master/src/test/java/smoke/IntegrationTests.java" target="_top">here</a>.</li><li class="listitem">once the tests pass we&#8217;re searching for the last production release. Once the application
is deployed to production we&#8217;re tagging it with <code class="literal">prod/${version}</code> tag. If there is no such tag
(there was no production release) there will be no rollback tests executed. If there was
a production release the tests will get executed.</li><li class="listitem">assuming that there was a production release we&#8217;re checking out the code corresponding to that
release (we&#8217;re checking out the tag), we&#8217;re downloading the appropriate fat jar and we&#8217;re uploading
it to Cloud Foundry. <span class="strong"><strong>IMPORTANT</strong></span> the <span class="emphasis"><em>old</em></span> jar is running against the <span class="strong"><strong>NEW</strong></span> version of the database.</li><li class="listitem">we&#8217;re running the <span class="emphasis"><em>old</em></span> <code class="literal">smoke</code> tests against the freshly deployed application surrounded by stubs.
If those tests pass then we have a high probability that the application is backwards compatible</li><li class="listitem">the default behaviour is that after all of those steps the user can manually click to deploy the
application to a stage environment</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_stage" href="#_stage"></a>Stage</h4></div></div></div><div class="figure"><a name="d0e734" href="#d0e734"></a><p class="title"><b>Figure&nbsp;2.9.&nbsp;End to end tests on stage environment</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/stage.png" alt="stage"></div></div></div><br class="figure-break"><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">starting a RabbitMQ service in Cloud Foundry</li><li class="listitem">deploying <code class="literal">Eureka</code> infrastructure application to Cloud Foundry</li><li class="listitem">downloading the fat jar from Nexus and we&#8217;re uploading it to Cloud Foundry.</li></ul></div><p>Next we have a manual step in which:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">from the checked out code we&#8217;re running the tests available under the <code class="literal">e2e</code> profile. In the
case of <a class="link" href="https://github.com/spring-cloud-samples/github-analytics/" target="_top">GitHub Analytics</a> application
we&#8217;re sending a HTTP message to GitHub Analytic&#8217;s endpoint. Then we&#8217;re checking if
the received message count has increased. You can check those tests <a class="link" href="https://github.com/spring-cloud-samples/github-analytics/blob/master/src/test/java/e2e/E2eTests.java" target="_top">here</a>.</li></ul></div><p>The step is manual by default due to the fact that stage environment is often shared between
teams and some preparations on databases / infrastructure have to take place before running the tests.
Ideally these step should be fully automatic.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_prod" href="#_prod"></a>Prod</h4></div></div></div><div class="figure"><a name="d0e778" href="#d0e778"></a><p class="title"><b>Figure&nbsp;2.10.&nbsp;Deployment to production</b></p><div class="figure-contents"><div class="mediaobject"><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-pipelines/master/docs-sources/src/main/asciidoc/images/intro/prod.png" alt="prod"></div></div></div><br class="figure-break"><p>The step to deploy to production is manual but ideally it should be automatic.</p><p>Here we&#8217;re</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">starting a RabbitMQ service in Cloud Foundry (only for the demo to pass - you should provision
the prod environment in a different way)</li><li class="listitem">deploying <code class="literal">Eureka</code> infrastructure application to Cloud Foundry (only for the demo to pass - you should provision
the prod environment in a different way)</li><li class="listitem">tagging the Git repo with <code class="literal">prod/${version}</code> tag</li><li class="listitem">downloading the fat jar from Nexus</li><li class="listitem">we&#8217;re doing Blue Green deployment on Cloud Foundry</li><li class="listitem">we&#8217;re renaming the current instance of the app e.g. <code class="literal">fooService</code> to <code class="literal">fooService-venerable</code></li><li class="listitem">we&#8217;re deploying the new instance of the app under the <code class="literal">fooService</code> name</li><li class="listitem">now two instances of the same application are running on production</li><li class="listitem">in the <code class="literal">Complete switch over</code> which is a manual step</li><li class="listitem">we&#8217;re deleting the old instance</li><li class="listitem">remember to run this step only after you have confirmed that both instances are working fine!</li></ul></div></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="multi__the_opinionated_pipeline.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="multi_concourse.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;The opinionated pipeline&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="multi_spring-cloud-pipelines.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Concourse Pipeline</td></tr></table></div></body></html>